"""
Planner Agent — synthesises stored signals into a ranked daily action list.

Reads:
  - DayPlan.context_summary + meetings_today (extracted by intake-agent)
  - CustomerRequests (P0/P1, stale)
  - StrategicInsights (risk, high confidence)

Produces:
  - Ranked FocusItems (3-5)
  - Completed DayPlan saved to storage

Does NOT:
  - Read raw files (intake-agent's job)
  - Run staleness or risk analysis (analyst-agent's job)
  - Generate StrategicInsight records (analyst-agent's job)
"""

import json
from datetime import date as _date

from openai import OpenAI

from config import MODEL, OPENAI_API_KEY
from models import DayPlan, FocusItem
from storage import StorageManager


SYSTEM_PROMPT = """You are the Planner Agent for a PM Strategy Copilot.

Your sole job is to synthesise structured signals into a ranked daily action list for a Technical Program Manager.

You receive:
1. Context summary from today's briefing (emails, Teams, customer mentions)
2. Today's meeting schedule
3. Open high-priority customer requests (P0/P1 that are stale or unresolved)
4. Recent risk insights generated by the Analyst

You produce exactly 3–5 FocusItems, ranked by urgency and importance.

Each FocusItem must follow What → Why → Action structure:
- title: a short action-oriented title (verb + object)
- what: the specific situation or task
- why: why it matters TODAY (not generally)
- source_type: customer_request | calendar | email | teams | insight | backlog
- source_ref: the ID or reference of the source (e.g., insight ID, meeting title, email subject)
- linked_request_ids: list of CustomerRequest IDs this item addresses
- estimated_minutes: realistic time estimate

Ranking rules:
1. P0 customer requests always surface first (production-blocking)
2. Time-boxed events (meetings) with prep needed come next
3. Risk insights with no in-plan action come next
4. Stale P1 requests last

Return valid JSON only — no markdown fences.
"""

PLANNER_PROMPT = """Generate a ranked daily focus list for {date}.

## Context Summary (from today's briefing):
{context_summary}

## Today's Meetings:
{meetings}

## Open High-Priority Requests (P0/P1, stale or unresolved):
{requests}

## Recent Risk Insights (high confidence, not yet in a plan):
{insights}

Return exactly this JSON structure (no markdown fences):
{{
  "focus_items": [
    {{
      "rank": 1,
      "title": "Action-oriented title",
      "what": "Specific situation or task description",
      "why": "Why this matters today specifically",
      "source_type": "customer_request|calendar|email|teams|insight|backlog",
      "source_ref": "ID or reference (insight ID, meeting title, email subject)",
      "linked_request_ids": ["req_id1"],
      "estimated_minutes": 30,
      "done": false
    }}
  ]
}}

Generate {min_items}–{max_items} focus items. Rank them by urgency."""


def _format_requests(requests) -> str:
    if not requests:
        return "None"
    lines = []
    for req in requests:
        stale_info = ""
        if req.surface_count == 0:
            stale_info = "never surfaced"
        else:
            stale_info = f"surfaced {req.surface_count}x, last: {req.last_surfaced_at or 'unknown'}"
        lines.append(
            f"[{req.id}] {req.priority} {req.classification}: {req.description} ({stale_info})"
        )
    return "\n".join(lines)


def _format_meetings(meetings: list[dict]) -> str:
    if not meetings:
        return "No meetings today"
    lines = []
    for m in meetings:
        lines.append(
            f"{m.get('start_time', '?')}  {m.get('title', 'Untitled')} ({m.get('duration_min', '?')} min)"
        )
    return "\n".join(lines)


def _format_insights(insights) -> str:
    if not insights:
        return "None"
    lines = []
    for ins in insights:
        lines.append(
            f"[{ins.id}] RISK·{ins.confidence}: {ins.what} — Action: {ins.recommended_action}"
        )
    return "\n".join(lines)


class PlannerAgent:
    def __init__(self, storage: StorageManager):
        self.storage = storage
        self.client = OpenAI(api_key=OPENAI_API_KEY)

    def _call_claude(self, user_content: str) -> str:
        response = self.client.chat.completions.create(
            model=MODEL,
            max_tokens=3000,
            messages=[
                {"role": "system", "content": SYSTEM_PROMPT},
                {"role": "user", "content": user_content},
            ],
        )
        return response.choices[0].message.content.strip()

    def _parse_json(self, text: str) -> dict:
        text = text.strip()
        if text.startswith("```"):
            lines = text.split("\n")
            text = "\n".join(lines[1:-1] if lines[-1] == "```" else lines[1:])
        return json.loads(text)

    def build_day_plan(
        self,
        partial_plan: DayPlan,
        min_items: int = 3,
        max_items: int = 5,
    ) -> DayPlan:
        """
        Given a partially-built DayPlan (context + meetings from intake-agent),
        generate and save the full DayPlan with ranked FocusItems.
        """
        today = partial_plan.date or _date.today().isoformat()

        # Read stored signals
        stale_requests = self.storage.list_requests(
            priority=["P0", "P1"],
            stale_days=3,  # stale if not surfaced in 3+ days
        )
        # Also include P0s that have never been surfaced
        never_surfaced_p0 = self.storage.list_requests(priority=["P0"])
        all_high_priority = {r.id: r for r in stale_requests}
        for r in never_surfaced_p0:
            if r.surface_count == 0:
                all_high_priority[r.id] = r
        priority_requests = list(all_high_priority.values())[:10]  # cap at 10

        risk_insights = self.storage.list_insights(
            insight_type=["risk"],
            confidence=["high"],
            recent_days=7,
        )
        risk_insights = [ins for ins in risk_insights if not ins.in_day_plan][:5]

        prompt = PLANNER_PROMPT.format(
            date=today,
            context_summary=partial_plan.context_summary or "No briefing context available.",
            meetings=_format_meetings(partial_plan.meetings_today),
            requests=_format_requests(priority_requests),
            insights=_format_insights(risk_insights),
            min_items=min_items,
            max_items=max_items,
        )

        raw = self._call_claude(prompt)

        try:
            data = self._parse_json(raw)
            items_data = data.get("focus_items", [])
        except (json.JSONDecodeError, KeyError):
            items_data = []

        focus_items = []
        for i, item in enumerate(items_data[:max_items], 1):
            focus_items.append(
                FocusItem(
                    rank=item.get("rank", i),
                    title=item.get("title", f"Focus item {i}"),
                    what=item.get("what", ""),
                    why=item.get("why", ""),
                    source_type=item.get("source_type", "backlog"),
                    source_ref=item.get("source_ref", ""),
                    linked_request_ids=item.get("linked_request_ids", []),
                    estimated_minutes=item.get("estimated_minutes", 30),
                    done=False,
                )
            )

        partial_plan.focus_items = focus_items
        self.storage.save_day_plan(partial_plan)
        return partial_plan
